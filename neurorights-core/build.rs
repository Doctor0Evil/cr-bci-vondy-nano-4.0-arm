use std::{env, fs, path::PathBuf};

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set"));

    let config = fs::read_to_string("neurorights.toml")
        .expect("neurorights.toml missing in neurorights-core");
    let parsed: toml::Value = toml::from_str(&config).expect("invalid neurorights.toml");

    let policy = parsed
        .get("policy")
        .expect("[policy] missing in neurorights.toml");

    let id = policy.get("id").and_then(|v| v.as_str()).expect("policy.id missing");
    let version = policy
        .get("version")
        .and_then(|v| v.as_str())
        .expect("policy.version missing");
    let anchor = policy
        .get("anchor")
        .and_then(|v| v.as_str())
        .expect("policy.anchor missing");

    // Here you can additionally fetch/validate the remote ALN shard
    // and derive numeric invariants (e.g., MAX_SCORE) if desired.

    let gen = format!(
        r#"
        // @generated by neurorights-core build.rs

        pub const NEURORIGHTS_POLICY_ID: &str = "{id}";
        pub const NEURORIGHTS_POLICY_VERSION: &str = "{version}";
        pub const NEURORIGHTS_POLICY_ANCHOR: &str = "{anchor}";

        // Example compile-time invariant hooks; wire to ALN shard values:
        pub const MAX_INNER_STATE_SCORE: u32 = 0;
        pub const ALLOW_NEUROCOERCION: bool = false;

        // Static sanity checks; expand with real invariants as the ALN shard matures.
        const _: () = {{
            // no inner-state scoring allowed
            assert!(MAX_INNER_STATE_SCORE == 0);
            assert!(!ALLOW_NEUROCOERCION);
        }};
        "#
    );

    fs::write(out_dir.join("generated_neurorights.rs"), gen)
        .expect("failed to write generated_neurorights.rs");
    println!("cargo:rerun-if-changed=neurorights.toml");
}
